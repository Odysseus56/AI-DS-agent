import os
from datetime import datetime, timezone, timedelta
from supabase import create_client, Client
import streamlit as st
import json

def utc_to_pst(utc_timestamp: str) -> str:
    """Convert UTC timestamp to PST/PDT format for display with abbreviated month."""
    try:
        # Parse UTC timestamp
        utc_time = datetime.fromisoformat(utc_timestamp.replace('Z', '+00:00'))
        
        # Convert to Pacific Time (handles PST/PDT automatically)
        # Pacific Time is UTC-8 (PST) or UTC-7 (PDT) depending on daylight saving
        pacific_time = utc_time - timedelta(hours=8)  # PST offset
        
        # Simple DST check (March-November is PDT in US)
        # This is a simplified check - for production, use timezone libraries
        if 3 <= pacific_time.month <= 11:
            pacific_time = utc_time - timedelta(hours=7)  # PDT offset
            timezone_name = "PDT"
        else:
            timezone_name = "PST"
        
        # Format for display with abbreviated month (Jan, Feb, etc.)
        return pacific_time.strftime("%Y-%b-%d %H:%M:%S") + f" {timezone_name}"
    except:
        return utc_timestamp  # Fallback to original if parsing fails


def utc_to_user_timezone(utc_timestamp: str, user_timezone: str = 'America/Los_Angeles') -> str:
    """Convert UTC timestamp to user's local timezone format for display."""
    try:
        # Import here to avoid issues if not available
        import pytz
        
        # Parse UTC timestamp
        utc_time = datetime.fromisoformat(utc_timestamp.replace('Z', '+00:00'))
        
        # Convert to user's timezone
        try:
            user_tz = pytz.timezone(user_timezone)
            local_time = utc_time.astimezone(user_tz)
            
            # Get timezone abbreviation (EST, EDT, PST, PDT, etc.)
            timezone_abbr = local_time.tzname()
            
            # Format for display with abbreviated month
            return local_time.strftime("%Y-%b-%d %H:%M:%S") + f" {timezone_abbr}"
        except pytz.UnknownTimeZoneError:
            # Fallback to PST if timezone is not recognized
            return utc_to_pst(utc_timestamp)
    except ImportError:
        # Fallback to PST if pytz is not available
        return utc_to_pst(utc_timestamp)
    except:
        return utc_timestamp  # Fallback to original if parsing fails

class SupabaseLogger:
    """
    Persistent logger using Supabase (free PostgreSQL).
    All logs are stored in the cloud and accessible via dashboard.
    """
    
    def __init__(self, session_timestamp=None):
        # Get Supabase credentials from Streamlit secrets
        try:
            supabase_url = st.secrets.get("SUPABASE_URL")
            supabase_key = st.secrets.get("SUPABASE_KEY")
        except:
            # Fallback to environment variables for local development
            supabase_url = os.getenv("SUPABASE_URL")
            supabase_key = os.getenv("SUPABASE_KEY")
        
        if supabase_url and supabase_key:
            self.supabase: Client = create_client(supabase_url, supabase_key)
            self.enabled = True
        else:
            self.enabled = False
            print("⚠️ Supabase credentials not found. Logging disabled.")
        
        self.session_timestamp = session_timestamp or datetime.now(timezone.utc).strftime("%Y-%m-%d_%H-%M-%S")
        self.interaction_count = 0
    
    def log_interaction(self, interaction_type: str, user_question: str = None, 
                       generated_code: str = None, execution_result: str = None,
                       llm_response: str = None, success: bool = True, 
                       error: str = None, metadata: dict = None):
        """
        Log any interaction to Supabase.
        
        Args:
            interaction_type: Type of interaction (e.g., 'analysis', 'visualization', 'text_qa', 'dataset_upload')
            user_question: User's question or request
            generated_code: Python code generated by LLM
            execution_result: Result from code execution
            llm_response: Final response to user
            success: Whether the interaction succeeded
            error: Error message if failed
            metadata: Additional data (execution_plan, evaluation, etc.)
        """
        if not self.enabled:
            return
        
        self.interaction_count += 1
        
        try:
            data = {
                "session_id": self.session_timestamp,
                "interaction_number": self.interaction_count,
                "interaction_type": interaction_type,
                "timestamp": datetime.now(timezone.utc).isoformat(),
                "user_question": user_question,
                "generated_code": generated_code,
                "execution_result": execution_result,
                "llm_response": llm_response,
                "success": success,
                "error": error,
                "metadata": json.dumps(metadata) if metadata else None
            }
            
            # Insert into Supabase
            self.supabase.table("interaction_logs").insert(data).execute()
            
        except Exception as e:
            print(f"⚠️ Failed to log to Supabase: {str(e)}")
    
    def log_text_qa(self, user_question: str, llm_response: str):
        """Log a simple text-based Q&A interaction."""
        self.log_interaction(
            interaction_type="text_qa",
            user_question=user_question,
            llm_response=llm_response,
            success=True
        )
    
    def log_analysis_workflow(self, user_question: str, question_type: str, 
                             generated_code: str, execution_result: str, 
                             final_answer: str, success: bool, error: str = "",
                             execution_plan: dict = None, evaluation: str = None):
        """Log a detailed analysis workflow."""
        self.log_interaction(
            interaction_type="analysis",
            user_question=user_question,
            generated_code=generated_code,
            execution_result=execution_result,
            llm_response=final_answer,
            success=success,
            error=error,
            metadata={
                "question_type": question_type,
                "execution_plan": execution_plan,
                "evaluation": evaluation
            }
        )
    
    def log_visualization_workflow(self, user_question: str, question_type: str,
                                   generated_code: str, explanation: str, 
                                   success: bool, figures: list = None, error: str = "",
                                   execution_plan: dict = None, evaluation: str = None):
        """Log a detailed visualization workflow."""
        self.log_interaction(
            interaction_type="visualization",
            user_question=user_question,
            generated_code=generated_code,
            execution_result=f"Generated {len(figures) if figures else 0} visualization(s)",
            llm_response=explanation,
            success=success,
            error=error,
            metadata={
                "question_type": question_type,
                "execution_plan": execution_plan,
                "evaluation": evaluation,
                "figure_count": len(figures) if figures else 0
            }
        )
    
    def log_summary_generation(self, summary_type: str, llm_response: str):
        """Log initial data summary generation."""
        self.log_interaction(
            interaction_type="dataset_upload",
            user_question=f"Dataset upload: {summary_type}",
            llm_response=llm_response,
            success=True
        )
    
    def get_session_logs(self, session_id: str = None):
        """Retrieve logs for a specific session."""
        if not self.enabled:
            return []
        
        try:
            if session_id:
                response = self.supabase.table("interaction_logs").select("*").eq("session_id", session_id).order("timestamp", desc=True).execute()
            else:
                response = self.supabase.table("interaction_logs").select("*").order("timestamp", desc=True).execute()
            return response.data
        except Exception as e:
            print(f"⚠️ Failed to retrieve logs: {str(e)}")
            return []
    
    def get_all_sessions(self):
        """Get list of all unique sessions."""
        if not self.enabled:
            return []
        
        try:
            response = self.supabase.table("interaction_logs").select("session_id").execute()
            
            # Get unique session IDs
            sessions = list(set([row["session_id"] for row in response.data]))
            return sorted(sessions, reverse=True)
        except Exception as e:
            print(f"⚠️ Failed to retrieve sessions: {str(e)}")
            return []
